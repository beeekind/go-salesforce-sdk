package main

import (
	"os"
	"text/template"

	"github.com/b3ntly/salesforce/client"
	"github.com/b3ntly/salesforce/codegen"
)

// definition.go contains utility functions for generating salesforce type
// definitions

var gopath = os.Getenv("GOPATH")

// ObjectDefinition ...
type ObjectDefinition struct {
	Client    *client.Client
	Object    *codegen.Struct
	Relations codegen.Structs
}

// Options ...
func (o *ObjectDefinition) Options() ([]codegen.Option, error) {
	entityName := "Account"
	entities, err := defineEntity(entityName, 1)
	if err != nil {
		return nil, err
	}

	for _, entity := range entities {
		if entity.Name == entityName {
			o.Object = entity
		} else {
			o.Relations = append(o.Relations, entity)
		}
	}

	return []codegen.Option{
		codegen.WithPackageName("accounts"),
		codegen.WithOutputDirectory("./autogenerated/"),
		codegen.WithTemplateMap(map[string]*template.Template{
			"objects.go":   template.Must(template.New("objects.gohtml").Funcs(codegen.DefaultFuncMap).ParseFiles(gopath + "/src/github.com/b3ntly/salesforce/templates/objects.gohtml")),
			"relations.go": template.Must(template.New("objects.relations.gohtml").Funcs(codegen.DefaultFuncMap).ParseFiles(gopath + "/src/github.com/b3ntly/salesforce/templates/objects.relations.gohtml")),
			// "api.go": template.Must(template.New("objects.api.gohtml").Funcs(codegen.DefaultFuncMap).ParseFiles(GOPATH + "/src/github.com/b3ntly/salesforce/templates/objects.api.gohtml")),
		}),
		codegen.WithData(o),
	}, nil
}

/**
// MetadataDefinition creates the metadata package
type MetadataDefinition struct {
	Client       *Client
	Services     map[string]string
	ServiceTypes []string
	ObjectTypes  []string
}

// Options ...
func (meta *MetadataDefinition) Options() (opts []codegen.Option, err error) {
	meta.Services, err = meta.gatherServiceURLs()
	if err != nil {
		return nil, fmt.Errorf("gathering services: %w", err)
	}

	meta.ServiceTypes, err = meta.gatherServiceTypes(meta.Services)
	if err != nil {
		return nil, fmt.Errorf("gathering service types :%w", err)
	}

	meta.ObjectTypes, err = meta.gatherMetadataObjects("EntityDefinition")
	if err != nil {
		return nil, fmt.Errorf("gathering metadataObjectTypes: %w", err)
	}

	return []codegen.Option{
		codegen.WithPackageName("metadata"),
		codegen.WithOutputDirectory("./"),
		codegen.WithTemplateMap(map[string]*template.Template{
			"metadata.go":  template.Must(template.New("metadata.gohtml").Funcs(codegen.DefaultFuncMap).ParseFiles(GOPATH + "/src/github.com/b3ntly/salesforce/templates/metadata.gohtml")),
			"types.go":     template.Must(template.New("metadata.types.gohtml").Funcs(codegen.DefaultFuncMap).ParseFiles(GOPATH + "/src/github.com/b3ntly/salesforce/templates/metadata.types.gohtml")),
			"endpoints.go": template.Must(template.New("metadata.endpoints.gohtml").Funcs(codegen.DefaultFuncMap).ParseFiles(GOPATH + "/src/github.com/b3ntly/salesforce/templates/metadata.endpoints.gohtml")),
		}),
		codegen.WithData(meta),
	}, nil
}

// GatherServices ...
func (meta *MetadataDefinition) gatherServiceURLs() (map[string]string, error) {
	fmt.Println("gathering service urls...")
	services, err := meta.Client.Services()
	if err != nil {
		return nil, err
	}

	// do some normalization on the data
	m := make(map[string]string)
	for name, endpoint := range services {
		name = strings.Title(strings.ReplaceAll(name, "-", ""))
		endpointParts := strings.Split(endpoint, "/")
		if name == "identity" {
			m[name] = endpoint
			continue
		}

		m[name] = endpointParts[len(endpointParts)-1]
	}

	return m, nil
}

// GatherServiceResponses ...
func (meta *MetadataDefinition) gatherServiceTypes(endpoints map[string]string) (results []string, err error) {
	fmt.Println("gathering service types...")

	additions, err := meta.Client.GetTypes("Describe", "/sobjects/Lead/describe")
	if err != nil {
		return nil, err
	}

	serviceNames := make([]string, len(endpoints))
	requests := make([]*http.Request, len(endpoints))
	idx := 0

	for serviceName, endpoint := range endpoints {
		requests[idx], err = reqs.Base.URL(meta.Client.URL(endpoint)).Request()
		if err != nil {
			return nil, fmt.Errorf("GatherServiceResponses(2): %w", err)
		}

		serviceNames[idx] = serviceName
		idx++
	}

	responses, err := meta.Client.DoMany(requests...)
	if err != nil {
		return nil, fmt.Errorf("GatherServiceResponses(3): %w", err)
	}

	var objects codegen.Structs
	for i := 0; i < len(responses); i++ {
		contents, err := ReadAndCloseResponse(responses[i])
		if err != nil {
			// we ignore this error because we still want to generate
			// types for error responses
			//
			// return fmt.Errorf("GatherServiceResponses(4): %w", err)
			continue
		}

		newObjects, err := codegen.FromJSON(serviceNames[i], "", contents)
		if err != nil {
			continue
		}

		objects = append(objects, newObjects...)
	}

	for _, obj := range objects.Merge(nil, codegen.MergeAll, true) {
		if obj.Name == "Url" {
			continue
		}

		result, err := obj.String()
		if err != nil {
			return nil, fmt.Errorf("executing Struct.String(): %w", err)
		}

		results = append(results, result)
	}

	return results, nil
}
*/
