// Package tree implements the Salesforce Tree resource allowing users to save nested objects
// in a single API operation
//
// https://developer.salesforce.com/docs/atlas.en-us.api_rest.meta/api_rest/resources_composite_sobject_tree.htm
package tree

import (
	"encoding/json"
	"errors"
	"fmt"
	"math/rand"
	"net/http"
	"reflect"
	"strings"
	"time"

	"github.com/b3ntly/salesforce/requests"
	"github.com/b3ntly/salesforce/types"
)

func init() {
	rand.Seed(time.Now().UnixNano())
}

var letterRunes = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")

func str(n int) string {
	b := make([]rune, n)
	for i := range b {
		b[i] = letterRunes[rand.Intn(len(letterRunes))]
	}
	return string(b)
}

var (
	// ErrRequestHasNoRecords ...
	ErrRequestHasNoRecords = errors.New("request has no records")
)

// Response ...
type Response struct {
	HasErrors bool      `json:"hasErrors"`
	Results   []*Result `json:"results"`
}

// Err ...
func (r *Response) Err() error {
	if !r.HasErrors {
		return nil
	}

	var buffer strings.Builder
	for _, result := range r.Results {
		for _, err := range result.Errors {
			buffer.WriteString(fmt.Sprintf("%s\n", err.StatusCode))
		}
	}

	return errors.New(buffer.String())
}

// Result ...
type Result struct {
	ReferenceID string   `json:"referenceId"`
	ID          string   `json:"id"`
	Errors      []*Error `json:"errors"`
}

// Error ...
type Error struct {
	StatusCode string   `json:"statusCode"`
	Message    string   `json:"message"`
	Fields     []string `json:"fields"`
}

// Request ...
type Request struct {
	Records []*Node `json:"records"`
}

// Node represents an object that can be marshalled into a Tree request. Type definitions
// generated by this library should conform to this type automatically.
type Node struct {
	Attributes *types.Attributes
	Fields     map[string]interface{}
	Children   map[string]*Request
}

// MarshalJSON ...
func (n *Node) MarshalJSON() ([]byte, error) {
	final := make(map[string]interface{})
	final["attributes"] = n.Attributes

	for k, v := range n.Fields {
		final[k] = v
	}

	for k, v := range n.Children {
		final[k] = v
	}

	return json.Marshal(final)
}

// Create ...
func Create(req requests.Builder, objectType string, nodes ...*Node) (response *Response, err error) {
	contents, err := req.
		URL(fmt.Sprintf("%s/%s/%s", "composite", "tree", objectType)). //"composite/tree/sObjectName").
		Method(http.MethodPost).
		Header("Content-Type", "application/json").
		Marshal(&Request{nodes}).
		JSON(&response)

	if err != nil {
		println(string(contents))
		return nil, err
	}

	return response, nil
}

// ParseNode validates that a given struct conforms to the required components
// of a Tree Request.
//
// * must have an attributes property which contains a type and referenceId field.
// * must not include an Id field (as the object hasn't been created yet)
// * nested objects must also conform to a TreeRequest type
func ParseNode(object interface{}) (*Node, error) {
	value := reflect.Indirect(reflect.ValueOf(object))
	if !value.IsValid() {
		return nil, errors.New("value is invalid")
	}

	node := &Node{
		Attributes: &types.Attributes{
			Type:        value.Type().Name(),
			ReferenceID: str(10),
		},
		Fields:   make(map[string]interface{}),
		Children: make(map[string]*Request),
	}

	for i := 0; i < value.NumField(); i++ {
		field := value.Field(i)
		if field.IsZero() {
			continue
		}

		name := value.Type().Field(i).Name
		if name == "Attributes" {
			attrs, ok := field.Interface().(*types.Attributes)
			if !ok {
				return nil, fmt.Errorf("casting Attributes to *types.Attributes")
			}
			node.Attributes = attrs
			continue
		}

		parts := strings.Split(value.Type().Field(i).Tag.Get("json"), ",")
		tagName := parts[len(parts)-1]

		switch field.Kind() {
		case reflect.Struct:
			records := field.FieldByName("Records")
			if records.IsValid() {
				var children []*Node
				for j := 0; j < records.Len(); j++ {
					item := records.Index(j).Interface()
					node, err := ParseNode(item)
					if err != nil {
						return nil, err
					}
					children = append(children, node)
				}
				node.Children[name] = &Request{children}
			} else {
				node.Fields[tagName] = field.Interface()
			}

		default:
			node.Fields[tagName] = field.Interface()
		}
	}

	return node, nil
}
